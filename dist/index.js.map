{
  "version": 3,
  "sources": ["..\\src\\rest.ts", "..\\src\\problem.ts", "..\\src\\bitfield.ts", "..\\src\\events.ts", "..\\src\\verifier.ts", "..\\src\\parser.ts", "..\\src\\webhooks.ts"],
  "sourcesContent": [
    "import { getCompatibility, getUa } from './const' with { type: 'macro' };\r\n\r\nimport axios, { AxiosInstance } from 'axios';\r\nimport { Problem } from './problem';\r\nimport { FsbStaticApiV2EventList, FsbStaticApiV2ProblemList, FsbStaticApiV2Schema, FsbStaticApiV2SchemaList } from './types';\r\n\r\n\r\ntype Options = {\r\n  baseUrl?: string,\r\n};\r\n\r\nconst defaultOptions: Options = {\r\n  baseUrl: 'https://api.freestuffbot.xyz/v2', \r\n};\r\n\r\nfunction handleError(err: any): never {\r\n  if (!axios.isAxiosError(err)) {\r\n    if (err instanceof Error) {\r\n      throw err;\r\n    }\r\n\r\n    throw new Error('An unknown error occurred', { cause: err });\r\n  }\r\n\r\n  if (err.response) {\r\n    if (err.response.data\r\n      && typeof err.response.data === 'object'\r\n      && err.response.data.type\r\n      && String(err.response.data.type).startsWith('fsb:problem:')\r\n    ) {\r\n      throw new Problem(err.response.data as Record<string, unknown>);\r\n    }\r\n    throw new Problem({\r\n      type: 'fsb:problem:internal:api_error',\r\n      title: 'API Error',\r\n      detail: `Received an error response from the API: ${err.response.status} - ${err.response.statusText}`,\r\n      raw: err.response.data,\r\n    });\r\n  } else if (err.request) {\r\n    throw new Problem({\r\n      type: 'fsb:problem:internal:request_failed',\r\n      title: 'Request Failed',\r\n      detail: `No response received from the server. Request details: ${JSON.stringify(err.request)}`,\r\n    });\r\n  } else {\r\n    throw new Problem({\r\n      type: 'fsb:problem:internal:request_setup_failed',\r\n      title: 'Request Setup Failed',\r\n      detail: `An error occurred while setting up the request: ${err.message}`,\r\n    });\r\n  }\r\n}\r\n\r\nexport class RestApiClient {\r\n\r\n  private client: AxiosInstance;\r\n\r\n  constructor(\r\n    token: string,\r\n    options?: Options,\r\n  ) {\r\n    this.client = axios.create({\r\n      baseURL: options?.baseUrl || defaultOptions.baseUrl,\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'User-Agent': getUa(),\r\n        'Content-Type': 'application/json',\r\n        'X-Set-Compatibility-Date': getCompatibility(),\r\n      },\r\n    });\r\n  }\r\n\r\n  public getPing() {\r\n    return this.client\r\n      .get('/ping')\r\n      .then(res => res.data)\r\n      .catch(handleError)\r\n  }\r\n\r\n  public readonly static = {\r\n    getSchemas: () => this.client\r\n      .get<FsbStaticApiV2SchemaList>('/static/schemas')\r\n      .then(res => res.data)\r\n      .catch(handleError),\r\n    getSchema: (urn: string) => this.client\r\n      .get<FsbStaticApiV2Schema>(`/static/schemas/${urn}`)\r\n      .then(res => res.data)\r\n      .catch(handleError),\r\n    getProblems: () => this.client\r\n      .get<FsbStaticApiV2ProblemList>('/static/problems')\r\n      .then(res => res.data)\r\n      .catch(handleError),\r\n    getEvents: () => this.client\r\n      .get<FsbStaticApiV2EventList>('/static/events')\r\n      .then(res => res.data)\r\n      .catch(handleError),\r\n  }\r\n\r\n}\r\n",
    "\r\n\r\nexport class Problem extends Error {\r\n\r\n  public readonly type: string;\r\n  public readonly title: string;\r\n  public readonly detail: string;\r\n\r\n  constructor(\r\n    public readonly raw: Record<string, unknown>,\r\n  ) {\r\n    super();\r\n    this.type = String(raw.type ?? 'fsb:problem:unknown');\r\n    this.title = String(raw.title ?? 'Unknown Problem');\r\n    this.detail = String(raw.detail ?? 'An unknown error occurred');\r\n  }\r\n\r\n}\r\n",
    "\r\n\r\nexport type Bitfield<Items extends string> = {\r\n  has: (item: Items) => boolean;\r\n  add: (item: Items) => void;\r\n  remove: (item: Items) => void;\r\n  toggle: (item: Items) => void;\r\n  getBits: () => number;\r\n  toString: () => string;\r\n  toArray: () => Items[];\r\n  size: () => number;\r\n  [Symbol.iterator]: () => IterableIterator<Items>;\r\n}\r\n\r\nexport function createBitfield<Items extends string>(from: number, model: Record<Items, number>): Bitfield<Items> {\r\n  let local = from;\r\n\r\n  const iterate = function* () {\r\n    for (const item of Object.keys(model) as Items[]) {\r\n      if (local & model[item]) {\r\n        yield item;\r\n      }\r\n    }\r\n  };\r\n\r\n  return {\r\n    has: (item) => (local & model[item]) !== 0,\r\n    add: (item) => void (local |= model[item]),\r\n    remove: (item) => void (local &= ~model[item]),\r\n    toggle: (item) => void (local ^= model[item]),\r\n    getBits: () => local,\r\n    toString : () => [ ...iterate() ].join(', '),\r\n    toArray : () => [ ...iterate() ],\r\n    size: () => [ ...iterate() ].length,\r\n    [Symbol.iterator]: () => iterate(),\r\n  };\r\n}\r\n",
    "import { EventEmitter } from 'node:events';\r\nimport { FsbEvent } from './types';\r\n\r\n\r\ntype EventType = FsbEvent['type'];\r\n\r\nexport type Listener<T extends EventType> = (event: FsbEvent & { type: T }) => any;\r\n\r\nconst emitter = new EventEmitter();\r\n\r\nexport function on<T extends EventType>(event: T, listener: Listener<T>) {\r\n  emitter.on(event, listener);\r\n}\r\n\r\nexport function once<T extends EventType>(event: T, listener: Listener<T>) {\r\n  emitter.once(event, listener);\r\n}\r\n\r\nexport function off<T extends EventType>(event: T, listener: Listener<T>) {\r\n  emitter.off(event, listener);\r\n}\r\n\r\nexport function emit(event: FsbEvent) {\r\n  emitter.emit(event.type, event);\r\n}\r\n",
    "import { createPublicKey, verify, type KeyObject } from 'node:crypto';\r\nimport { parseEpochTimestamp } from './parser'\r\n\r\n\r\nexport type VerifierOptions = {\r\n  /** the public key to verify the message payload against */\r\n  publicKey: string | KeyObject\r\n  /** controls the timestamp check and for how long messageIds are stored */\r\n  maxMessageAge?: number\r\n  /** skip storing and comparing messageIds for replay attacks, not recommended */\r\n  skipDuplicateCheck?: boolean\r\n  /** skip checking the timestamp for dates in the past, not recommended */\r\n  skipTimestampCheck?: boolean\r\n};\r\n\r\nexport type VerificationInput = {\r\n  /** the raw message body as a buffer (http body, **not parsed**) */\r\n  data: Buffer,\r\n  /** the payload signature (webhook-signature header) */\r\n  signature: string,\r\n  /** the message id (webhook-id header) */\r\n  messageId: string,\r\n  /** the string timestamp of this message's delivery (webhook-timestamp header) */\r\n  timestamp: string,\r\n};\r\n\r\nexport type VerificationStatus\r\n  /** the input was verified and is valid */\r\n  = 'valid'\r\n  /** some of the input parameters are missing */\r\n  | 'missing-parameters'\r\n  /** the signature was not matching the input */\r\n  | 'invalid-signature'\r\n  /** the timestamp was invalid, e.g. too old */\r\n  | 'invalid-timestamp'\r\n  /** the signature was created using an unsupported algorithm */\r\n  | 'unsupported-algorithm'\r\n  /** this message has already been received before */\r\n  | 'duplicate';\r\n\r\nexport type VerificationOutput = {\r\n  success: true\r\n  status: 'valid'\r\n  payloadJson: Record<string, unknown> | null\r\n  payloadRaw: Buffer\r\n} | {\r\n  success: false\r\n  status: Omit<VerificationStatus, 'valid'>\r\n  payloadJson: null\r\n  payloadRaw: null\r\n};\r\n\r\nexport type SignedMessageVerifier = (input: VerificationInput) => VerificationOutput;\r\n\r\nexport function newSignedMessageVerifier(options: VerifierOptions) {\r\n  const key = (typeof options.publicKey === 'string')\r\n    ? createPublicKey({\r\n      key: Buffer.from(options.publicKey, 'base64'),\r\n      format: 'der',\r\n      type: 'spki',\r\n    })\r\n    : options.publicKey;\r\n\r\n  const maxMessageAge = options.maxMessageAge ?? 5 * 60 * 1000; // default to 5 minutes\r\n  const skipDuplicateCheck = options.skipDuplicateCheck ?? false;\r\n  const skipTimestampCheck = options.skipTimestampCheck ?? false;\r\n\r\n  const storedMessageIds: Set<string> = new Set();\r\n  const deleteMessageIdsAfter = maxMessageAge + 1 * 60 * 1000; // keep for 1 minute longer to be sure\r\n\r\n  const isDateOlderThanMaxAge = (date: Date): boolean => {\r\n    const now = new Date();\r\n    return (now.getTime() - date.getTime()) > maxMessageAge;\r\n  };\r\n\r\n  return (input: VerificationInput): VerificationOutput => {\r\n    if (!input.data || !input.signature || !input.messageId || !input.timestamp) {\r\n      return {\r\n        success: false,\r\n        status: 'missing-parameters',\r\n        payloadJson: null,\r\n        payloadRaw: null,\r\n      };\r\n    }\r\n\r\n    const asDate = parseEpochTimestamp(input.timestamp);\r\n    if (!skipTimestampCheck && (!asDate || isNaN(asDate.getTime()) || isDateOlderThanMaxAge(asDate))) {\r\n      return {\r\n        success: false,\r\n        status: 'invalid-timestamp',\r\n        payloadJson: null,\r\n        payloadRaw: null,\r\n      };\r\n    }\r\n\r\n    if (!skipDuplicateCheck && storedMessageIds.has(input.messageId)) {\r\n      return {\r\n        success: false,\r\n        status: 'duplicate',\r\n        payloadJson: null,\r\n        payloadRaw: null,\r\n      };\r\n    }\r\n\r\n    if (skipDuplicateCheck) {\r\n      storedMessageIds.add(input.messageId);\r\n      setTimeout(() => {\r\n        storedMessageIds.delete(input.messageId);\r\n      }, deleteMessageIdsAfter);\r\n    }\r\n\r\n    const [version, sigB64] = String(input.signature).split(',');\r\n    if (version !== 'v1a') {\r\n      return {\r\n        success: false,\r\n        status: 'unsupported-algorithm',\r\n        payloadJson: null,\r\n        payloadRaw: null,\r\n      };\r\n    }\r\n\r\n    const sigBuff = Buffer.from(sigB64!, 'base64');\r\n    const contentBuff = Buffer.from(`${input.messageId}.${input.timestamp}.${input.data.toString()}`, 'utf8');\r\n\r\n    const valid = verify(null, new Uint8Array(contentBuff), key, sigBuff);\r\n    if (!valid) {\r\n      return {\r\n        success: false,\r\n        status: 'invalid-signature',\r\n        payloadJson: null,\r\n        payloadRaw: null,\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      status: 'valid',\r\n      payloadJson: input.data.toString()\r\n        ? JSON.parse(input.data.toString())\r\n        : null,\r\n      payloadRaw: input.data,\r\n    }\r\n  };\r\n}\r\n",
    "import { createBitfield } from './bitfield'\r\nimport type { FsbEvent, Product, ResolvedAnnouncement } from './types';\r\n\r\n\r\nconst productFlags = {\r\n  TRASH: 1<<0,\r\n  THIRDPARTY: 1<<1,\r\n  PERMANENT: 1<<2,\r\n  STAFF_PICK: 1<<3,\r\n  FIRSTPARTY_EXCLUSIVE: 1<<4,\r\n};\r\n\r\nconst productUrlFlags = {\r\n  ORIGINAL: 1<<0,\r\n  PROXIED: 1<<1,\r\n  TRACKING: 1<<2,\r\n  OPENS_IN_BROWSER: 1<<3,\r\n  OPENS_IN_CLIENT: 1<<4,\r\n};\r\n\r\nconst productImageFlags = {\r\n  PROXIED: 1<<0,\r\n  AR_WIDE: 1<<1,\r\n  AR_SQUARE: 1<<2,\r\n  AR_TALL: 1<<3,\r\n  TP_PROMO: 1<<4,\r\n  TP_LOGO: 1<<5,\r\n  TP_SHOWCASE: 1<<6,\r\n  TP_OTHER: 1<<7,\r\n  FT_WATERMARK: 1<<8,\r\n  FT_TAGS: 1<<9,\r\n};\r\n\r\nfunction parseProduct(product: Record<string, unknown>): Product {\r\n  product.until = product.until\r\n    ? new Date(product.until as string)\r\n    : null;\r\n  product.flags = createBitfield(product.flags as number, productFlags);\r\n  (product.urls as Array<Record<string, unknown>>).forEach(url => url.flags = createBitfield(url.flags as number, productUrlFlags));\r\n  (product.images as Array<Record<string, unknown>>).forEach(image => image.flags = createBitfield(image.flags as number, productImageFlags));\r\n  return product as Product;\r\n}\r\n\r\nfunction parseResolvedAnnouncement(announcement: Record<string, unknown>): ResolvedAnnouncement {\r\n  announcement.resolvedProducts = (announcement.resolvedProducts as Array<Record<string, unknown>>).map(parseProduct);\r\n  return announcement as ResolvedAnnouncement;\r\n}\r\n\r\nconst epochBegin = new Date('2025-01-01T00:00:00Z').getTime()\r\nexport function parseEpochTimestamp(timestamp: unknown): Date | null {\r\n  const asNumber = Number(timestamp);\r\n  if (isNaN(asNumber) || asNumber < 0) {\r\n    return null;\r\n  }\r\n  return new Date(epochBegin + asNumber * 1000);\r\n}\r\n\r\nexport function parseEvent(event: Record<string, unknown>): FsbEvent {\r\n  if (event.type as string === 'fsb:event:product_updated') {\r\n    event.data = parseProduct(event.data as Record<string, unknown>);\r\n  } else if (event.type as string === 'fsb:event:announcement_created') {\r\n    event.data = parseResolvedAnnouncement(event.data as Record<string, unknown>);\r\n  }\r\n  event.timestamp = new Date(String(event.timestamp));\r\n  return event as FsbEvent;\r\n}\r\n",
    "import { getCompatibility, getUa } from './const' with { type: 'macro' };\r\n\r\nimport type { Request, Response, NextFunction } from 'express';\r\nimport type { KeyObject } from 'node:crypto';\r\nimport express, { raw } from 'express';\r\nimport { newSignedMessageVerifier, type VerifierOptions } from './verifier';\r\nimport { emit } from './events';\r\nimport { parseEvent } from './parser';\r\n// import { createFactory } from 'hono/factory';\r\n// import { HTTPException } from 'hono/http-exception';\r\n\r\n\r\ntype ExpressOptions = Partial<Omit<VerifierOptions, 'publicKey'> & { debug?: boolean; }>\r\n\r\n/** Add freestuff webhooks to any existing express app */\r\nexport function createExpressHandler(pubkey: string | KeyObject, options?: ExpressOptions) {\r\n  const verifier = newSignedMessageVerifier({\r\n    publicKey: pubkey,\r\n    ...(options ?? {}),\r\n  });\r\n\r\n  const rawParser = raw({ type: '*/*' });\r\n\r\n  return (req: Request, res: Response, next: NextFunction) => {\r\n    rawParser(req, res, (err) => {\r\n      res.header('X-Set-Compatibility-Date', getCompatibility());\r\n      res.header('X-Client-Library', getUa());\r\n\r\n      if (err) {\r\n        return void res.status(500).send('Error parsing request body');\r\n      }\r\n\r\n      if (!req.body) {\r\n        return void res.status(400).send('Missing body');\r\n      }\r\n\r\n      if (!Buffer.isBuffer(req.body)) {\r\n        console.warn('Webhook body is not a Buffer! Please move any mentions of `use(express.json())` after the webhook handler.');\r\n        return void res.status(500).send('Invalid server configuration');\r\n      }\r\n\r\n      const result = verifier({\r\n        data: req.body,\r\n        signature: String(req.headers['webhook-signature']),\r\n        messageId: String(req.headers['webhook-id']),\r\n        timestamp: String(req.headers['webhook-timestamp']),\r\n      });\r\n\r\n      if (options?.debug) {\r\n        console.log('in>', {\r\n          data: req.body,\r\n          signature: String(req.headers['webhook-signature']),\r\n          messageId: String(req.headers['webhook-id']),\r\n          timestamp: String(req.headers['webhook-timestamp']),\r\n        });\r\n        console.log('out>', result);\r\n      }\r\n\r\n      if (!result.success) {\r\n        return void res.status(400).send(`Verification failed: ${result.status}`);\r\n      }\r\n\r\n      const compatibilityDate = req.headers['x-compatibility-date'];\r\n      if (compatibilityDate !== getCompatibility()) {\r\n        return void res.status(400).send('Incompatible compatibility date');\r\n      }\r\n\r\n      res.status(204).end();\r\n\r\n      if (!result.payloadJson.type || !String(result.payloadJson.type).startsWith('fsb:event:')) {\r\n        console.warn(`Received a correctly signed but unsupported payload.`);\r\n        console.log(result.payloadJson);\r\n        return;\r\n      }\r\n\r\n      emit(parseEvent(result.payloadJson));\r\n    });\r\n  };\r\n}\r\n\r\n/** Let us create an express server for you and already register everything you need. */\r\nexport function createExpressServer(options: VerifierOptions & { port?: number, route?: string, debug?: boolean }) {\r\n  const handler = createExpressHandler(options.publicKey, options);\r\n  const app = express();\r\n  if (options.route) {\r\n    app.use(options.route, handler);\r\n  } else {\r\n    app.use(handler);\r\n  }\r\n  const { promise, resolve } = Promise.withResolvers<{ app: typeof app, port: number }>();\r\n  const port = options.port ?? 3000;\r\n  app.listen(port, () => resolve({ app, port }));\r\n  return promise;\r\n}\r\n\r\n\r\n// type HonoOptions = Partial<Omit<VerifierOptions, 'publicKey'> & { debug?: boolean; }>\r\n\r\n// export function createHonoHandler(pubkey: string | KeyObject, options?: HonoOptions) {\r\n//   const factory = createFactory();\r\n//   const verifier = newSignedMessageVerifier({\r\n//     publicKey: pubkey,\r\n//     ...(options ?? {}),\r\n//   });\r\n\r\n//   return factory.createHandlers(async (c) => {\r\n//     c.header('X-Set-Compatibility-Date', getCompatibility());\r\n//     c.header('X-Client-Library', getUa());\r\n\r\n//     const body = await c.req.arrayBuffer()\r\n//       .then((ab) => Buffer.from(ab))\r\n//       .catch((e) => {\r\n//         throw new HTTPException(500, { message: 'Error parsing request body' });\r\n//       });\r\n\r\n//     if (!body) {\r\n//       throw new HTTPException(400, { message: 'Missing body' });\r\n//     }\r\n\r\n//     if (!Buffer.isBuffer(body)) {\r\n//       throw new HTTPException(500, { message: 'Invalid server configuration' });\r\n//     }\r\n\r\n//     const result = verifier({\r\n//       data: body,\r\n//       signature: String(c.req.header('webhook-signature')),\r\n//       messageId: String(c.req.header('webhook-id')),\r\n//       timestamp: String(c.req.header('webhook-timestamp')),\r\n//     });\r\n\r\n//     if (options?.debug) {\r\n//       console.log('in>', {\r\n//         data: body,\r\n//         signature: String(c.req.header('webhook-signature')),\r\n//         messageId: String(c.req.header('webhook-id')),\r\n//         timestamp: String(c.req.header('webhook-timestamp')),\r\n//       });\r\n//       console.log('out>', result);\r\n//     }\r\n\r\n//     if (!result.success) {\r\n//       throw new HTTPException(400, { message: `Verification failed: ${result.status}` });\r\n//     }\r\n\r\n//     const compatibilityDate = c.req.header('x-compatibility-date');\r\n//     if (compatibilityDate !== getCompatibility()) {\r\n//       throw new HTTPException(400, { message: 'Incompatible compatibility date' });\r\n//     }\r\n\r\n//     emit(parseEvent(result.payloadJson));\r\n\r\n//     return c.newResponse(null, 204);\r\n//   })\r\n// }\r\n"
  ],
  "mappings": "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",
  "debugId": "1C719AA061DC2A0264756E2164756E21",
  "names": []
}